<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GSR Stress Monitor - Local UI</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    :root {
      --primary: #3b82f6;
      --secondary: #10b981;
      --surface: #f3f4f6;
      --background: #ffffff;
      --text: #1f2937;
      --subtext: #6b7280;
    }
    body { font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background-color: var(--background); color: var(--text); margin:0; padding:20px; display:flex; justify-content:center; }
    .container { width:100%; max-width:1200px; }
    header { text-align:center; margin-bottom:30px; padding-bottom:20px; border-bottom:1px solid var(--surface); }
    header h1{ color:var(--primary); margin:0; font-weight:600 }
    .controls { display:flex; justify-content:center; gap:12px; margin-bottom:20px; align-items:center }
    .button { padding:10px 20px; border:none; border-radius:8px; font-size:16px; cursor:pointer; font-weight:500 }
    #startButton{ background:var(--secondary); color:#fff }
    #stopButton{ background:#ef4444; color:#fff }
    .card{ background:var(--surface); padding:20px; border-radius:12px; box-shadow:0 4px 6px rgba(0,0,0,0.05); text-align:center }
    .stats-grid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(250px,1fr)); gap:20px; margin-bottom:30px }
    .chart-container{ background:var(--surface); padding:20px; border-radius:12px; height:400px }
    .stage-info { margin-bottom: 20px; padding: 15px; border: 1px solid var(--primary); border-radius: 8px; background-color: #eff6ff; }
    .stage-header { display:flex; justify-content:space-between; align-items:center }

    /* Camera box */
    .cam-box{ position:fixed; top:20px; left:20px; width:220px; height:160px; background:#ffffffcc; border-radius:10px; overflow:hidden; box-shadow:0 6px 18px rgba(0,0,0,0.12); z-index:1200; display:flex; align-items:center; justify-content:center; }
    .cam-box video{ width:100%; height:100%; object-fit:cover }
    .cam-controls { position:fixed; top:190px; left:20px; z-index:1200; }
    #camToggleBtn{ padding:8px 12px; border-radius:6px; border:none; background:#3b82f6; color:#fff; cursor:pointer }
    input[type="text"], input[type="url"]{ padding:8px 10px; border-radius:6px; border:1px solid #e5e7eb }

    /* Toast Notification System */
    #uploadToast {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: #10b981;
      color: #fff;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 2000;
      font-weight: 500;
      max-width: 400px;
      animation: slideInUp 0.3s ease-out;
    }
    #uploadToast.error {
      background: #ef4444;
    }
    #uploadToast.warning {
      background: #f59e0b;
    }
    #uploadToast.info {
      background: #3b82f6;
    }
    #toastIcon {
      font-size: 20px;
    }
    #toastMessage {
      flex: 1;
    }
    @keyframes slideInUp {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- Toast Notification -->
  <div id="uploadToast" aria-live="polite" aria-atomic="true">
    <i id="toastIcon" class="fas fa-check-circle"></i>
    <span id="toastMessage">Operation successful</span>
  </div>

  <div class="container">
    <div id="camBox" class="cam-box" aria-live="polite">
      <video id="localVideo" autoplay playsinline muted></video>
      <canvas id="camCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none"></canvas>
    </div>
    <div class="cam-controls">
      <button id="camToggleBtn">Open Camera</button>
    </div>

    <header>
      <h1>GSR Stress Monitor</h1>
      <p>Real-time Galvanic Skin Response (GSR) Monitoring</p>
    </header>

    <div class="controls">
      <label for="volunteerNumber" style="display:flex;align-items:center;gap:8px">
        Volunteer:
        <input id="volunteerNumber" type="number" min="1" style="width:80px;padding:8px;border-radius:6px;border:1px solid #e5e7eb" />
      </label>
      <input id="espInput" type="url" placeholder="http://192.168.x.x" />
      <button id="saveEspBtn" class="button">Set ESP</button>
      <button id="startButton" class="button">Start Session</button>
      <button id="stopButton" class="button" disabled>Stop & Download CSV</button>
    </div>

    <div class="stage-info">
      <div class="stage-header">
        <h2>Stage: <span id="stageDescription">Waiting to start...</span></h2>
        <div class="stage-timer-display">Remaining: <span id="stageTimer">--:--</span></div>
      </div>
      <div class="progress-bar-container"><div id="stageProgress" style="height:8px;width:0;background:var(--primary)"></div></div>
    </div>

    <div class="stats-grid">
      <div class="card">
        <div class="card-title">Conductance Value</div>
        <div class="card-value" id="conductanceValue">-- µS</div>
      </div>
      <div class="card">
        <div class="card-title">Session Elapsed Time</div>
        <div class="card-value" id="sessionTimer">00:00</div>
      </div>
    </div>

    <div class="chart-container">
      <canvas id="chart"></canvas>
    </div>

    <!-- Toast Notification for upload status -->
    <div id="uploadToast" style="position: fixed; bottom: 20px; right: 20px; background: #10b981; color: white; padding: 16px 24px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 2000; display: none; max-width: 300px; font-size: 14px;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <i id="toastIcon" class="fas fa-check-circle"></i>
        <span id="toastMessage">File uploaded successfully!</span>
      </div>
    </div>
  </div>

  <script>
    // ESP base - ALWAYS use 10.155.83.100 (can be changed via UI)
    const DEFAULT_ESP = 'http://10.155.83.100';
    let ESP_BASE = DEFAULT_ESP;
    
    // Try to load from localStorage, but validate it
    const saved = localStorage.getItem('esp_base');
    if (saved && saved.trim().length > 0) {
      ESP_BASE = saved;
    }
    
    const espInput = document.getElementById('espInput');
    const saveEspBtn = document.getElementById('saveEspBtn');
    espInput.value = ESP_BASE;
    
    saveEspBtn.onclick = () => {
      const v = espInput.value.trim();
      if(!v) {
        ESP_BASE = DEFAULT_ESP;
        localStorage.setItem('esp_base', DEFAULT_ESP);
        espInput.value = DEFAULT_ESP;
        alert('Reset to default: ' + DEFAULT_ESP);
        return;
      }
      ESP_BASE = v;
      localStorage.setItem('esp_base', ESP_BASE);
      alert('Saved ESP base: ' + ESP_BASE);
    };

    // Chart.js init
    let chart = null;
    try {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        // chart will plot conductance in µS
        data: { labels: [], datasets: [{ label: 'Conductance (µS)', data: [], borderColor: getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#3b82f6', borderWidth:2, tension:0.3, pointRadius:0, fill:false }] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:false} }, scales:{ x:{ title:{ display:true, text:'Time (s)'} }, y:{ title:{ display:true, text:'Conductance (µS)'} } } }
      });
    } catch(e){ console.warn('Chart init failed', e); }

    let dataLog = [];
    let sessionActive = false;
    let intervalId = null;
    let autoDownloadExecuted = false;

    // Toast Notification System
    function showToast(message, type = 'success', duration = 4000) {
      const toast = document.getElementById('uploadToast');
      const icon = document.getElementById('toastIcon');
      const msgEl = document.getElementById('toastMessage');
      
      // Update type and icon
      toast.className = '';
      if (type === 'success') {
        toast.classList.add('');
        icon.className = 'fas fa-check-circle';
      } else if (type === 'error') {
        toast.classList.add('error');
        icon.className = 'fas fa-exclamation-circle';
      } else if (type === 'warning') {
        toast.classList.add('warning');
        icon.className = 'fas fa-exclamation-triangle';
      } else if (type === 'info') {
        toast.classList.add('info');
        icon.className = 'fas fa-info-circle';
      }
      
      msgEl.textContent = message;
      toast.style.display = 'flex';
      
      setTimeout(() => {
        toast.style.display = 'none';
      }, duration);
    }

    // Enhanced upload to OneDrive
    // Supports CSV and video with error handling and retry logic
    async function uploadToOneDrive(fileBlob, filename, volunteerId) {
      if (!volunteerId) {
        showToast('Volunteer ID required for upload', 'error');
        console.warn('No volunteer ID');
        return;
      }

      // Determine file type
      const fileType = filename.endsWith('.csv') ? 'csv' : 
                       filename.endsWith('.webm') ? 'video' : 'unknown';

      try {
        // Convert Blob to Base64
        showToast(`Uploading ${filename}...`, 'info');
        
        const reader = new FileReader();
        reader.onload = async () => {
          const base64Data = reader.result.split(',')[1];
          
          // Upload attempt with retry logic
          let retries = 3;
          let success = false;
          let lastError = null;

          while (retries > 0 && !success) {
            try {
              console.log(`Upload attempt ${4 - retries}/3: ${filename}`);
              
              const response = await fetch('http://localhost:5001/api/upload', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  volunteer_id: volunteerId,
                  filename: filename,
                  file_data: base64Data,
                  file_type: fileType
                })
              });

              if (response.ok) {
                const result = await response.json();
                showToast(`File ${filename} uploaded to OneDrive successfully!`, 'success');
                console.log('Upload response:', result);
                success = true;
              } else {
                const errorData = await response.json();
                lastError = errorData.error || `HTTP Error ${response.status}`;
                console.warn(`Attempt failed: ${lastError}`);
                retries--;
                
                if (retries > 0) {
                  console.log(`Retrying in 2 seconds...`);
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
              }
            } catch (fetchError) {
              lastError = fetchError.message;
              console.warn(`Connection error: ${lastError}`);
              retries--;
              
              if (retries > 0) {
                console.log(`Retrying in 2 seconds...`);
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            }
          }

          // If all attempts failed
          if (!success) {
            console.warn('Failed to upload to OneDrive after 3 attempts');
            console.warn(`Reason: ${lastError}`);
            showToast(`Upload to OneDrive failed. Saving locally only. (${lastError})`, 'warning');
            
            // Fallback: local save
            console.log(`Saving ${filename} locally...`);
          }
        };
        reader.readAsDataURL(fileBlob);
      } catch (error) {
        console.error('Error processing file:', error);
        showToast(`Error: ${error.message}`, 'error');
      }
    }

    function downloadCSV(filename){
      console.log('Loading CSV, dataLog length=', dataLog.length);
      const header = 'Time (s),Resistance (Ω),Conductance (µS),Stage\n';
      const rows = dataLog.length ? dataLog.reduce((acc,row)=> acc+`${row.elapsed},${row.resistance},${row.conductance},${row.stage}\n`, '') : '';
      const csv = header + rows;
      const blob=new Blob([csv],{type:'text/csv'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(filename||'GSR_Data') + '.csv';
      a.click();
      URL.revokeObjectURL(a.href);
      
      // Upload to OneDrive
      const volunteerId = document.getElementById('volunteerNumber').value;
      if (volunteerId) {
        uploadToOneDrive(blob, (filename || 'GSR_Data') + '.csv', volunteerId);
      }
    }

    document.getElementById('startButton').onclick = async () => {
      if(!ESP_BASE) return alert('Set ESP base first');
      dataLog = []; if(chart){ chart.data.labels=[]; chart.data.datasets[0].data=[]; chart.update(); }
      autoDownloadExecuted = false;
      try{
        await fetch(ESP_BASE + '/start');
        document.getElementById('startButton').disabled=true; document.getElementById('stopButton').disabled=false; sessionActive=true;
        if(!intervalId) intervalId=setInterval(fetchData,1000);
        // start recording automatically if camera open
        if(camStream) startRecording();
      }catch(e){ alert('Failed to contact ESP at ' + ESP_BASE); console.error(e); }
    };

    document.getElementById('stopButton').onclick = async () => {
      try{
        await fetch(ESP_BASE + '/stop');
        document.getElementById('startButton').disabled=false; document.getElementById('stopButton').disabled=true; sessionActive=false;
        if(intervalId){ clearInterval(intervalId); intervalId=null; }
        // stop recording (if active) and download video will be triggered by recorder.onstop
        stopRecording();
        // fallback: if recorder wasn't created but we have recordedChunks, download video blob
        if(!recorder && recordedChunks && recordedChunks.length){
          try{
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = volunteerName() + '.webm'; a.click(); URL.revokeObjectURL(url);
            recordedChunks = [];
          }catch(e){ console.warn('fallback video download failed', e); }
        }
        // always download CSV for this volunteer
        downloadCSV(volunteerName());
      }catch(e){ alert('Stop failed: ' + e); }
    };

    function formatTime(s){ const m=Math.floor(s/60); const sec=s%60; return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}` }

    async function fetchData(){ if(!sessionActive){ if(!autoDownloadExecuted && dataLog.length>0){ document.getElementById('stageDescription').textContent='Session complete. Downloading data...'; downloadCSV(volunteerName()); autoDownloadExecuted=true; if(intervalId){ clearInterval(intervalId); intervalId=null; } } return; }
      try{
        const resp = await fetch(ESP_BASE + '/resistance');
        const data = await resp.json();
        lastData = data || lastData;
        if(Object.keys(data).length===0 || data.finished){
          document.getElementById('startButton').disabled=false; document.getElementById('stopButton').disabled=false; sessionActive=false;
          // stop recording (if active) and download CSV for this volunteer
          stopRecording();
          if(!autoDownloadExecuted){ downloadCSV(volunteerName()); autoDownloadExecuted=true; }
          if(intervalId){ clearInterval(intervalId); intervalId=null; }
          return;
        }
        document.getElementById('stageTimer').textContent = formatTime(data.remaining);
        // Prefer the explicit stage name from ESP so UI matches CSV/video
        document.getElementById('stageDescription').textContent = data.stage || data.description;
        document.getElementById('sessionTimer').textContent = formatTime(data.elapsed);
        // compute conductance (S) and convert to µS for display/plot
        const resistance = data.value;
        let conductance = NaN;
        if(typeof resistance === 'number' && isFinite(resistance) && resistance > 0){ conductance = 1.0 / resistance; }
        const conductance_uS = isFinite(conductance) ? (conductance * 1e6) : NaN;
        // display conductance nicely
        let conductanceDisplay = '--';
        if(isFinite(conductance_uS)){
          conductanceDisplay = conductance_uS >= 1000 ? ((conductance_uS/1000).toFixed(2) + ' mS') : (conductance_uS.toFixed(2) + ' µS');
        }
        document.getElementById('conductanceValue').textContent = conductanceDisplay;
        const progress = (1 - (data.remaining / data.stageDuration)) * 100;
        document.getElementById('stageProgress').style.width = `${progress}%`;
        if(chart){ if(chart.data.labels.length>=600){ chart.data.labels.shift(); chart.data.datasets[0].data.shift(); } chart.data.labels.push(data.elapsed); chart.data.datasets[0].data.push(isFinite(conductance_uS) ? conductance_uS : null); chart.update(); }
        dataLog.push({ elapsed:data.elapsed, resistance: resistance, conductance: isFinite(conductance_uS) ? conductance_uS : '', stage:data.stage });
      }catch(e){ console.error('fetchData error', e); }
    }

    // Volunteer handling
    const volunteerNumberInput = document.getElementById('volunteerNumber');
    let volunteerNum = parseInt(localStorage.getItem('volunteer_num') || '1', 10);
    function volunteerName(){ return 'V' + volunteerNum; }
    volunteerNumberInput.value = volunteerNum;
    volunteerNumberInput.addEventListener('change', ()=>{
      const v = parseInt(volunteerNumberInput.value) || 1;
      volunteerNum = v;
      localStorage.setItem('volunteer_num', String(volunteerNum));
    });

    // Camera handling: toggle under camera + overlay + recording
    const videoEl = document.getElementById('localVideo');
    const camToggleBtn = document.getElementById('camToggleBtn');
    const camCanvas = document.getElementById('camCanvas');
    const camCtx = camCanvas.getContext('2d');
    let camStream = null;
    let recording = false;
    let recorder = null;
    let recordedChunks = [];
    let overlayRAF = null;
    let lastData = { elapsed:0, remaining:0, value:0, stage:'', description:'' };
    function isSafari(){ return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); }

    async function startCamera(){
      if(camStream) return; // already running
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ camToggleBtn.style.display='none'; return; }
      try{
        camStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
        videoEl.srcObject = camStream;
        camToggleBtn.textContent = 'Close Camera';
        await new Promise(resolve => { if (videoEl.readyState >= 2) resolve(); else videoEl.onloadedmetadata = resolve; });
        const w = videoEl.videoWidth || videoEl.clientWidth;
        const h = videoEl.videoHeight || videoEl.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        camCanvas.width = Math.floor(w * dpr);
        camCanvas.height = Math.floor(h * dpr);
        camCanvas.style.width = videoEl.clientWidth + 'px';
        camCanvas.style.height = videoEl.clientHeight + 'px';
        camCtx.setTransform(dpr,0,0,dpr,0,0);
      } catch(err){
        console.error('Camera start failed:', err);
        camStream = null;
        camToggleBtn.textContent = 'Open Camera';
      }
    }

    function stopCamera(){
      if(!camStream) return;
      camStream.getTracks().forEach(t=>t.stop());
      camStream = null;
      videoEl.srcObject = null;
      camToggleBtn.textContent = 'Open Camera';
      if(!recording && overlayRAF){ cancelAnimationFrame(overlayRAF); overlayRAF = null; camCtx.clearRect(0,0,camCanvas.width,camCanvas.height); }
    }

    camToggleBtn.onclick = () => { if(camStream) stopCamera(); else startCamera(); };

    // overlay draw loop (improved: two boxes to avoid overlap, show conductance, draw chart inset)
    function wrapText(ctx, text, maxWidth){
      const words = text.split(' ');
      const lines = [];
      let line = '';
      for(const w of words){
        const test = line ? (line + ' ' + w) : w;
        const m = ctx.measureText(test).width;
        if(m > maxWidth && line){ lines.push(line); line = w; } else { line = test; }
      }
      if(line) lines.push(line);
      return lines;
    }

    function drawOverlay(){
      if(!videoEl || videoEl.readyState < 2){ overlayRAF = requestAnimationFrame(drawOverlay); return; }
      const dpr = window.devicePixelRatio || 1;
      const w = camCanvas.width / dpr;
      const h = camCanvas.height / dpr;
      camCtx.clearRect(0,0,camCanvas.width,camCanvas.height);
      camCtx.drawImage(videoEl, 0, 0, w, h);

      // left box: volunteer + stage (wrap if needed)
      const pad = 8;
      const leftW = Math.min(w * 0.58, 320);
      const rightW = Math.min(w * 0.34, 220);
      const boxY = pad;
      // compute lines for stage
      camCtx.font = '14px Inter, system-ui, Arial';
      // prefer the explicit stage name so overlay matches UI/CSV
      const stageText = (lastData.stage || lastData.description || '--');
      const stageLines = wrapText(camCtx, stageText, leftW - 20);
      const leftBoxH = Math.max(40, 18 + stageLines.length * 18 + 6);

      camCtx.fillStyle = 'rgba(0,0,0,0.45)';
      camCtx.fillRect(pad, boxY, leftW, leftBoxH);
      camCtx.fillStyle = '#fff';
      camCtx.font = '14px Inter, system-ui, Arial';
      camCtx.fillText('Volunteer: ' + volunteerName(), pad + 6, boxY + 18);
      // draw stage lines
      for(let i=0;i<stageLines.length;i++){
        camCtx.fillText(stageLines[i], pad + 6, boxY + 18 + (i+1)*16);
      }

      // right box: time + conductance
      const rightX = Math.max(w - rightW - pad, pad + leftW + 6);
      const rightBoxH = 56;
      camCtx.fillStyle = 'rgba(0,0,0,0.45)';
      camCtx.fillRect(rightX, boxY, rightW, rightBoxH);
      camCtx.fillStyle = '#fff';
      camCtx.font = '14px Inter, system-ui, Arial';
      camCtx.fillText('Time: ' + formatTime(Math.floor(lastData.elapsed || 0)), rightX + 8, boxY + 20);
      // compute conductance (siemens) = 1 / resistance
      let condDisplay = '--';
      if(typeof lastData.value === 'number' && isFinite(lastData.value) && lastData.value > 0){
        const g = 1.0 / lastData.value; // siemens
        const gu = g * 1e6; // microsiemens
        condDisplay = gu >= 1000 ? ( (gu/1000).toFixed(2) + ' mS' ) : (gu.toFixed(2) + ' µS');
      }
      camCtx.fillText('Conductance: ' + condDisplay, rightX + 8, boxY + 40);

      // draw small chart inset bottom-right (use Chart.js canvas if available)
      let chartCanvas = null;
      try{ chartCanvas = (chart && chart.canvas) ? chart.canvas : document.getElementById('chart'); }catch(e){ chartCanvas = document.getElementById('chart'); }
      if(chartCanvas){
        const insetW = Math.min(w * 0.34, 360);
        const insetH = Math.min(h * 0.28, 220);
        const insetX = Math.max(w - insetW - pad, rightX + rightW + 6);
        const insetY = h - insetH - pad;
        try{ if(chart && typeof chart.update === 'function') chart.update(); camCtx.drawImage(chartCanvas, insetX, insetY, insetW, insetH); }catch(e){ /* ignore if chart not ready */ }
      }

      overlayRAF = requestAnimationFrame(drawOverlay);
    }

    function startRecording(){
      if(!camStream || recording) return;
      if(!overlayRAF) drawOverlay();
      recordedChunks = [];
      const canvasStream = camCanvas.captureStream(25);
      try{
        recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm;codecs=vp8' });
      }catch(e){ recorder = new MediaRecorder(canvasStream); }
      recorder.ondataavailable = (e)=>{ if(e.data && e.data.size) recordedChunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = volunteerName() + '.webm'; a.click(); URL.revokeObjectURL(url);
        
        // Upload video to OneDrive with file type specified
        console.log('Uploading video...');
        const volunteerId = document.getElementById('volunteerNumber').value;
        if (volunteerId) {
          uploadToOneDrive(blob, volunteerName() + '.webm', volunteerId);
        }
        
        if(overlayRAF){ cancelAnimationFrame(overlayRAF); overlayRAF = null; }
        recording = false; recorder = null; recordedChunks = [];
        incrementVolunteer();
      };
      recorder.start();
      recording = true;
      console.log('Starting recording...');
    }

    function stopRecording(){
      if(recorder){ 
        try{ 
          console.log('Stopping recording...');
          recorder.stop(); 
        }catch(e){ console.warn('Failed to stop recorder:', e); } 
      }
      else {
        // No active recorder: increment volunteer number
        incrementVolunteer();
      }
    }

    function incrementVolunteer(){
      volunteerNum = (parseInt(localStorage.getItem('volunteer_num') || String(volunteerNum),10) || volunteerNum) + 1;
      localStorage.setItem('volunteer_num', String(volunteerNum));
      volunteerNumberInput.value = volunteerNum;
    }

    // On load: don't auto-start camera (user can toggle)
    window.addEventListener('load', ()=>{
      espInput.value = ESP_BASE;
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ camToggleBtn.style.display='none'; }
    });
  </script>
</body>
</html>
